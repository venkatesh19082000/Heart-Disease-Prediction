# -*- coding: utf-8 -*-
"""vchallag_ujwalako_phase3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yPgG5e1VeNPC_7khLYMc0IO9XQwl1RUG
"""

!pip install pyspark

!pip install findspark

!pip install pyngrok

from pyspark import SparkContext, SparkConf
import findspark

findspark.init()

from pyspark.sql import SparkSession

spark = SparkSession.builder.appName("Program1").getOrCreate()
sc = spark.sparkContext

from pyngrok import ngrok, conf
import getpass

print("Enter your authtoken, which can be copied "
"from https://dashboard.ngrok.com/get-started/your-authtoken")
conf.get_default().auth_token = getpass.getpass()

ui_port = 4040
public_url = ngrok.connect(ui_port).public_url
print(f" * ngrok tunnel \"{public_url}\" -> \"http://127.0.0.1:{ui_port}\"")

file_path = "/content/adult.csv"

df = spark.read.csv(file_path, header=True, inferSchema=True)
df.printSchema()
df.show(5)

from pyspark.sql.functions import when, col

df = df.replace("?", None)

df.show(5)

cols = ['age', 'workclass', 'education', 'occupation', 'income']
df = df.dropna(subset=cols)

df = df.dropDuplicates()

df.show(5)

from pyspark.sql.functions import col

df = df.filter((col('age') >= 18) & (col('age') <= 90))

df = df.toDF(*[c.replace('.', '_') for c in df.columns])

from pyspark.sql.functions import when, col, lit
from pyspark.sql.functions import udf
from pyspark.sql.types import StringType

def AgeSplit(age):
    if age < 30:
        return "Young"
    elif age < 60:
        return "Middle-aged"
    else:
        return "Senior"
AGEVal = udf(AgeSplit, StringType())
df = df.withColumn("age_category", AGEVal(col("age")))
df.show(10)

from pyspark.ml.feature import StringIndexer
from pyspark.ml import Pipeline

catcols = ['workclass', 'education', 'marital_status', 'occupation', 'relationship', 'race', 'sex', 'native_country', 'income']
for col in catcols:
    print(f"{col}: {df.schema[col].dataType}")
indexers = [StringIndexer(inputCol=col, outputCol="Encoded_"+col, handleInvalid="skip").fit(df) for col in catcols]
pipeline = Pipeline(stages=indexers)
df = pipeline.fit(df).transform(df)
df = df.drop(*catcols)
df.show(5)

from pyspark.ml.feature import StringIndexer, VectorAssembler
from pyspark.ml.classification import LogisticRegression
from pyspark.ml import Pipeline
from pyspark.ml.evaluation import MulticlassClassificationEvaluator
from pyspark.sql.functions import col, udf
from pyspark.sql.types import StringType
import findspark
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc, confusion_matrix
from pyspark.sql import SparkSession
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix

import time

start_time = time.time()

inputcols = [col for col in df.columns if col not in ['Encoded_income', 'age_category']]
assembler = VectorAssembler(inputCols=inputcols, outputCol="features")
LGM = LogisticRegression(labelCol="Encoded_income", featuresCol="features")
pipeline = Pipeline(stages=[assembler, LGM])
train_df, test_df = df.randomSplit([0.8, 0.2], seed=1234)
model = pipeline.fit(train_df)
predictions = model.transform(test_df)
Eaccu = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="accuracy")
EPrec = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="weightedPrecision")
Erecall = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="weightedRecall")
Ef1 = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="f1")

acc = Eaccu.evaluate(predictions)
prec = EPrec.evaluate(predictions)
recal = Erecall.evaluate(predictions)
F1 = Ef1.evaluate(predictions)

end_time = time.time()
execution_time = end_time - start_time

print(f"Accuracy of LR model is  {acc}")
print(f"Precision is  {prec}")
print(f"Recall is  {recal}")
print(f"F1 Score is {F1}")
print(f"Execution Time is {execution_time} seconds")

y_true = predictions.select("Encoded_income").rdd.flatMap(lambda x: x).collect()
y_pred = predictions.select("prediction").rdd.flatMap(lambda x: x).collect()
fpr, tpr, thresholds = roc_curve(y_true, y_pred)
roc_auc = auc(fpr, tpr)
plt.figure(figsize=(6, 5))
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.title('ROC')
plt.legend(loc="lower right")
plt.show()
CoM = confusion_matrix(y_true, y_pred)
plt.figure(figsize=(6, 5))
sns.heatmap(CoM, annot=True, fmt="d", cmap="Blues", xticklabels=["Predicted <=50K", "Predicted >50K"], yticklabels=["True <=50K", "True >50K"])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix for LR Model')
plt.show()

from pyspark.ml.feature import StringIndexer, VectorAssembler
from pyspark.ml.classification import DecisionTreeClassifier
from pyspark.ml import Pipeline
from pyspark.ml.evaluation import MulticlassClassificationEvaluator
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc, confusion_matrix
import seaborn as sns


start_time = time.time()
inputcols = [col for col in df.columns if col not in ['Encoded_income', 'age_category']]
assembler = VectorAssembler(inputCols=inputcols, outputCol="features")
DTM = DecisionTreeClassifier(labelCol="Encoded_income", featuresCol="features", maxBins=128)
pipeline = Pipeline(stages=[assembler, DTM])
model = pipeline.fit(train_df)
predictions = model.transform(test_df)
Eaccu = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="accuracy")
EPrec = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="weightedPrecision")
Erecall = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="weightedRecall")
Ef1 = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="f1")
acc = Eaccu.evaluate(predictions)
prec = EPrec.evaluate(predictions)
recal = Erecall.evaluate(predictions)
F1 = Ef1.evaluate(predictions)
end_time = time.time()
execution_time = end_time - start_time
print(f"Accuracy of the DT Model is {acc}")
print(f"Precision is  {prec}")
print(f"Recall is {recal}")
print(f"F1 Score is {F1}")
print(f"Execution Time is {execution_time} seconds")

y_true = predictions.select("Encoded_income").rdd.flatMap(lambda x: x).collect()
y_pred = predictions.select("prediction").rdd.flatMap(lambda x: x).collect()
FPR, TPR, thresholds = roc_curve(y_true, y_pred)
ROCA = auc(FPR, TPR)
plt.figure(figsize=(6, 5))
plt.plot(FPR, TPR, color='darkorange', lw=2, label=f'ROC curve (area = {ROCA:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.title('ROC')
plt.legend(loc="lower right")
plt.show()

CoM = confusion_matrix(y_true, y_pred)
plt.figure(figsize=(6, 5))
sns.heatmap(CoM, annot=True, fmt="d", cmap="Blues", xticklabels=["Predicted <=50K", "Predicted >50K"], yticklabels=["True <=50K", "True >50K"])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix for DT')
plt.show()

import findspark
from pyspark.sql import SparkSession
from pyspark.sql.functions import col, udf
from pyspark.sql.types import StringType
from pyspark.ml.feature import StringIndexer, VectorAssembler
from pyspark.ml.classification import (
    LogisticRegression,
    DecisionTreeClassifier,
    LinearSVC,
    RandomForestClassifier,
    NaiveBayes,
    GBTClassifier
)
from pyspark.ml import Pipeline
from pyspark.ml.evaluation import MulticlassClassificationEvaluator
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import roc_curve, auc, confusion_matrix

start_time = time.time()
Inputcols = [col for col in df.columns if col not in ['Encoded_income', 'age_category']]
ASS = VectorAssembler(inputCols=Inputcols, outputCol="features")
SVM = LinearSVC(labelCol="Encoded_income", featuresCol="features")
pipeline = Pipeline(stages=[ASS, SVM])
model = pipeline.fit(train_df)
predictions = model.transform(test_df)
Eaccu = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="accuracy")
EPrec = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="weightedPrecision")
Erecall = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="weightedRecall")
Ef1 = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="f1")

acc = Eaccu.evaluate(predictions)
prec = EPrec.evaluate(predictions)
recal = Erecall.evaluate(predictions)
F1 = Ef1.evaluate(predictions)
end_time = time.time()
execution_time = end_time - start_time

print(f"Accuracy of SVM model is  {acc}")
print(f"Precision is  {prec}")
print(f"Recall is  {recal}")
print(f"F1 Score is {F1}")
print(f"Execution Time is {execution_time} seconds")

y_true = predictions.select("Encoded_income").rdd.flatMap(lambda x: x).collect()
y_pred = predictions.select("prediction").rdd.flatMap(lambda x: x).collect()
fpr, tpr, thresholds = roc_curve(y_true, y_pred)
ROCA = auc(fpr, tpr)

plt.figure(figsize=(6, 5))
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {ROCA:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.title('ROC')
plt.legend(loc="lower right")
plt.show()


CoM = confusion_matrix(y_true, y_pred)
plt.figure(figsize=(6, 5))
sns.heatmap(CoM, annot=True, fmt="d", cmap="Blues", xticklabels=["Predicted <=50K", "Predicted >50K"], yticklabels=["True <=50K", "True >50K"])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix for SVM ')
plt.show()

start_time = time.time()
Inputcols = [col for col in df.columns if col not in ['Encoded_income', 'age_category']]
ASSem = VectorAssembler(inputCols=Inputcols, outputCol="features")
RFM = RandomForestClassifier(labelCol="Encoded_income", featuresCol="features", maxBins=50)
pipeline = Pipeline(stages=[ASSem, RFM])
model = pipeline.fit(train_df)
predictions = model.transform(test_df)
Eaccu = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="accuracy")
EPrec = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="weightedPrecision")
Erecall = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="weightedRecall")
Ef1 = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="f1")

acc = Eaccu.evaluate(predictions)
prec = EPrec.evaluate(predictions)
recal = Erecall.evaluate(predictions)
F1 = Ef1.evaluate(predictions)
end_time = time.time()
execution_time = end_time - start_time

print(f"Accuracy of Random Forest model is  {acc}")
print(f"Precision is  {prec}")
print(f"Recall is  {recal}")
print(f"F1 Score is {F1}")
print(f"Execution Time is {execution_time} seconds")

y_true = predictions.select("Encoded_income").rdd.flatMap(lambda x: x).collect()
y_pred = predictions.select("prediction").rdd.flatMap(lambda x: x).collect()
fpr, tpr, thresholds = roc_curve(y_true, y_pred)
ROCAUC = auc(fpr, tpr)

plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {ROCAUC:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.title('ROC')
plt.legend(loc="lower right")
plt.show()

CoM = confusion_matrix(y_true, y_pred)
plt.figure(figsize=(6, 5))
sns.heatmap(CoM, annot=True, fmt="d", cmap="Blues", xticklabels=["Predicted <=50K", "Predicted >50K"], yticklabels=["True <=50K", "True >50K"])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix for RF')
plt.show()

start_time = time.time()
Inputcols = [col for col in df.columns if col not in ['Encoded_income', 'age_category']]
Assem = VectorAssembler(inputCols=Inputcols, outputCol="features")
NBM = NaiveBayes(labelCol="Encoded_income", featuresCol="features", modelType="multinomial")
pipeline = Pipeline(stages=[Assem, NBM])
model = pipeline.fit(train_df)
predictions = model.transform(test_df)
Eaccu = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="accuracy")
EPrec = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="weightedPrecision")
Erecall = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="weightedRecall")
Ef1 = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="f1")

acc = Eaccu.evaluate(predictions)
prec = EPrec.evaluate(predictions)
recal = Erecall.evaluate(predictions)
F1 = Ef1.evaluate(predictions)
end_time = time.time()
execution_time = end_time - start_time

print(f"Accuracy of NB model is  {acc}")
print(f"Precision is  {prec}")
print(f"Recall is  {recal}")
print(f"F1 Score is {F1}")
print(f"Execution Time is {execution_time} seconds")

y_true = predictions.select("Encoded_income").rdd.flatMap(lambda x: x).collect()
y_pred = predictions.select("prediction").rdd.flatMap(lambda x: x).collect()
fpr, tpr, thresholds = roc_curve(y_true, y_pred)
ROCAUC = auc(fpr, tpr)
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {ROCAUC:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.title('ROC')
plt.legend(loc="lower right")
plt.show()
CoM = confusion_matrix(y_true, y_pred)
plt.figure(figsize=(6, 5))
sns.heatmap(CoM, annot=True, fmt="d", cmap="Blues", xticklabels=["Predicted <=50K", "Predicted >50K"], yticklabels=["True <=50K", "True >50K"])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix for NB ')
plt.show()

start_time = time.time()
Inputcols = [col for col in df.columns if col not in ['Encoded_income', 'age_category']]
ASSM = VectorAssembler(inputCols=Inputcols, outputCol="features")
GBTM = GBTClassifier(labelCol="Encoded_income", featuresCol="features", maxIter=128, maxBins=100)
pipeline = Pipeline(stages=[ASSM, GBTM])
model = pipeline.fit(train_df)
predictions = model.transform(test_df)
Eaccu = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="accuracy")
EPrec = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="weightedPrecision")
Erecall = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="weightedRecall")
Ef1 = MulticlassClassificationEvaluator(labelCol="Encoded_income", predictionCol="prediction", metricName="f1")

acc = Eaccu.evaluate(predictions)
prec = EPrec.evaluate(predictions)
recal = Erecall.evaluate(predictions)
F1 = Ef1.evaluate(predictions)
end_time = time.time()
execution_time = end_time - start_time
print(f"Accuracy of GBT model is  {acc}")
print(f"Precision is  {prec}")
print(f"Recall is  {recal}")
print(f"F1 Score is {F1}")
print(f"Execution Time is {execution_time} seconds")

y_true = predictions.select("Encoded_income").rdd.flatMap(lambda x: x).collect()
y_pred = predictions.select("prediction").rdd.flatMap(lambda x: x).collect()
fpr, tpr, thresholds = roc_curve(y_true, y_pred)
ROCAUC = auc(fpr, tpr)
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {ROCAUC:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.title('ROC')
plt.legend(loc="lower right")
plt.show()
CoM = confusion_matrix(y_true, y_pred)
plt.figure(figsize=(6, 5))
sns.heatmap(CoM, annot=True, fmt="d", cmap="Blues", xticklabels=["Predicted <=50K", "Predicted >50K"], yticklabels=["True <=50K", "True >50K"])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix for GBT')
plt.show()